/**
 * Generated by anjay_codegen.py on 2022-09-30 13:46:40
 *
 * LwM2M Object: Water meter
 * ID: 3424, URN: urn:oma:lwm2m:ext:3424, Optional, Multiple
 *
 * The uCIFI water meter measures water volume that was distributed
 * through a water meter, in pulse count as well as in m3. It also
 * detects anomalies in the water meter.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_list.h>
#include <avsystem/commons/avs_memory.h>
#include "objects/objects.h"
#include "driver/gpio.h"
#include "driver/timer.h"
#include "bulbulator.h"

#define TIMER_DIVIDER         (16)  //  Hardware timer clock divider
#define TIMER_SCALE           (TIMER_BASE_CLK / TIMER_DIVIDER)  // convert counter value to seconds

/**
 * Cumulated water volume: R, Single, Mandatory
 * type: float, range: N/A, unit: m3
 * Number of cubic meters of water distributed through the meter since
 * last reset.
 */
#define RID_CUMULATED_WATER_VOLUME 1

/**
 * Cumulated water meter value reset: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Reset the cumulated meter value.
 */
#define RID_CUMULATED_WATER_METER_VALUE_RESET 2

/**
 * Maximum flow rate: R, Single, Optional
 * type: float, range: N/A, unit: m3/s
 * Maximum flow rate since last metering value.
 */
#define RID_MAXIMUM_FLOW_RATE 8

typedef struct water_meter_instance_struct {
    anjay_iid_t iid;
    double cumulator_volume;
    double temp_volume;
    double temp_flow;
    double max_flow;
} water_meter_instance_t;

typedef struct water_meter_object_struct {
    const anjay_dm_object_def_t *def;
    AVS_LIST(water_meter_instance_t) instances;

    // TODO: object state
} water_meter_object_t;


static inline water_meter_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, water_meter_object_t, def);
}

static bool timer_group_isr_callback(void * args) {
   water_meter_instance_t *inst = (water_meter_instance_t *)args;
   inst->temp_flow = inst->temp_volume * (1 / 0.5f);
   inst->temp_volume = 0;
   if (inst->max_flow < inst->temp_flow) {inst->max_flow = inst->temp_flow;}
   return false;
}

static water_meter_instance_t *find_instance(const water_meter_object_t *obj,
                                             anjay_iid_t iid) {
    AVS_LIST(water_meter_instance_t) it;
    AVS_LIST_FOREACH(it, obj->instances) {
        if (it->iid == iid) {
            return it;
        } else if (it->iid > iid) {
            break;
        }
    }

    return NULL;
}

static void digital_input_state_changed(void *_obj) {
    water_meter_object_t *obj = (water_meter_object_t *) _obj;

    water_meter_instance_t *inst = find_instance(obj, 0);
    if (gpio_get_level(13)) {
        inst->cumulator_volume+=(double)1.0/490000.0;
        inst->temp_volume+=(double)1.0/490000.0;
    }
}
static int list_instances(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    AVS_LIST(water_meter_instance_t) it;
    AVS_LIST_FOREACH(it, get_obj(obj_ptr)->instances) {
        anjay_dm_emit(ctx, it->iid);
    }

    return 0;
}

static int init_instance(water_meter_instance_t *inst, anjay_iid_t iid) {
    assert(iid != ANJAY_ID_INVALID);

    inst->iid = iid;
    // TODO: instance init
    inst->cumulator_volume=0;
    // TODO: return 0 on success, negative value on failure
    return 0;
}

static void release_instance(water_meter_instance_t *inst) {
    // TODO: instance cleanup
    (void) inst;
}

static water_meter_instance_t *
add_instance(water_meter_object_t *obj, anjay_iid_t iid) {
    assert(find_instance(obj, iid) == NULL);

    AVS_LIST(water_meter_instance_t) created =
            AVS_LIST_NEW_ELEMENT(water_meter_instance_t);
    if (!created) {
        return NULL;
    }

    int result = init_instance(created, iid);
    if (result) {
        AVS_LIST_CLEAR(&created);
        return NULL;
    }

    AVS_LIST(water_meter_instance_t) *ptr;
    AVS_LIST_FOREACH_PTR(ptr, &obj->instances) {
        if ((*ptr)->iid > created->iid) {
            break;
        }
    }

    AVS_LIST_INSERT(ptr, created);
    return created;
}

static int instance_create(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void) anjay;
    water_meter_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    water_meter_instance_t *inst = find_instance(obj, iid);
    assert(inst);
    inst->temp_flow=0;
    inst->max_flow=0;
    inst->temp_volume=0;
    return add_instance(obj, iid) ? 0 : ANJAY_ERR_INTERNAL;
}

static int instance_remove(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void) anjay;
    water_meter_object_t *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST(water_meter_instance_t) *it;
    AVS_LIST_FOREACH_PTR(it, &obj->instances) {
        if ((*it)->iid == iid) {
            release_instance(*it);
            AVS_LIST_DELETE(it);
            return 0;
        } else if ((*it)->iid > iid) {
            break;
        }
    }

    assert(0);
    return ANJAY_ERR_NOT_FOUND;
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    water_meter_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    water_meter_instance_t *inst = find_instance(obj, iid);
    assert(inst);
    inst->cumulator_volume=0;
    inst->temp_flow=0;
    inst->max_flow=0;
    inst->temp_volume=0;
    // TODO: instance reset
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_CUMULATED_WATER_VOLUME,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_CUMULATED_WATER_METER_VALUE_RESET,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MAXIMUM_FLOW_RATE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    water_meter_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    water_meter_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_CUMULATED_WATER_VOLUME:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_double(ctx, inst->cumulator_volume); // TODO

    case RID_MAXIMUM_FLOW_RATE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_double(ctx, inst->max_flow); // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) anjay;
    (void) arg_ctx;

    water_meter_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    water_meter_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_CUMULATED_WATER_METER_VALUE_RESET:
        inst->cumulator_volume=0;
        inst->max_flow=0;
        bulb_state = BULBULATOR_START;
        return 0; // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 3424,
    .handlers = {
        .list_instances = list_instances,
        .instance_create = instance_create,
        .instance_remove = instance_remove,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_execute = resource_execute,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};
static const anjay_dm_object_def_t *OBJ_DEF_PTR = &OBJ_DEF;

const anjay_dm_object_def_t **water_meter_object_create(void) {
    water_meter_object_t *obj = (water_meter_object_t *) avs_calloc(1, sizeof(water_meter_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;
    water_meter_instance_t *inst=add_instance(obj,0);
    if(inst){
        gpio_config_t config = {
        .pin_bit_mask = BIT64(13),
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = true,
        .pull_down_en = false,
        .intr_type = GPIO_INTR_POSEDGE
        };

        if (gpio_config(&config) || gpio_isr_handler_add(13,
                                        digital_input_state_changed, obj)) {
            water_meter_object_release(&OBJ_DEF_PTR);
            gpio_reset_pin(13);
            return NULL;
        }

        timer_config_t time_config = {
            .divider = TIMER_DIVIDER,
            .counter_dir = TIMER_COUNT_UP,
            .counter_en = TIMER_PAUSE,
            .alarm_en = TIMER_ALARM_EN,
            .auto_reload = true,
        }; // default clock source is APB
        timer_init(TIMER_GROUP_0, TIMER_0, &time_config);

        /* Timer's counter will initially start from value below.
           Also, if auto_reload is set, this value will be automatically reload on alarm */
        timer_set_counter_value(TIMER_GROUP_0, TIMER_0, 0);

        /* Configure the alarm value and the interrupt on alarm. */
        timer_set_alarm_value(TIMER_GROUP_0, TIMER_0, 1 * TIMER_SCALE);
        timer_enable_intr(TIMER_GROUP_0, TIMER_0);

        timer_isr_callback_add(TIMER_GROUP_0, TIMER_0, timer_group_isr_callback, (void *)inst, 0);
        timer_start(TIMER_GROUP_0, TIMER_0);
    } else{
        avs_free(obj);
        return NULL;
    }

    return &obj->def;
}

void water_meter_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        water_meter_object_t *obj = get_obj(def);
        AVS_LIST_CLEAR(&obj->instances) {
            release_instance(obj->instances);
        }

        // TODO: object cleanup

        avs_free(obj);
    }
}
